---
title: 零长数组与柔性数组
date: 2021-10-01 10:30:38
tags:
---

![壁纸](03.jfif)

零长数组与柔性数组

<!--more-->



#### 1 零长数组或1长数组



下述示例，引自 《你必须知道的495个C语言问题》 2.7节。

```c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct name {
  int namelen;
   char namestr[1];
};

struct name *makename(char *newname)
{
    struct name *ret = 
        malloc(sizeof(struct name) - 1 + strlen(newname) + 1);
    	/*	-1 for initial [1]; +1 for \0	*/
    if(ret != NULL)
    {
        ret->namelen = strlen(newname);
        strcpy(ret->namestr, newname);
    }
    return ret;
}
```



linux 目录中

/usr/include/linux/if_pppox.h

```c

struct pppoe_tag{
    __u16 tag_type;
    __u16 tag_len;
    char tag_data[0];
} __attribute((packed));
```



Python-3.7.4/Objects/dict-common.h

```c

typedef strut {
    Py_hash_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictKeyEntry;

struct _dictkeysobject {
    Py_ssize_t dk_refcnt;
    Py_ssize_t dk_size;
    dict_lookup_func dk_lookup;
    Py_ssize_t dk_usable;
    Py_ssize_t dk_nentries;
    char dk_indices[];
};

static PyDictKeysObject *new_keys_object(Py_ssize_t size){
    //...
    dk = PyObject_MALLOC(sizeof(PyDictKeysObject)
                        + es * size
                        + sizeof(PyDictKeyEntry) *usable);
    // ...
}
```



结构体最后使用0或1 的长度数组的原因，主要是为了方便的管理内存缓冲区，如果你直接使用指针而不使用数组，那么你在分配内存的时候，需要分配两次，首先为结构体分配一次内存，然后再为结构体中的指针分配一次内存（此时分配的内存已经与结构体的内存不连续了，释放内存也需要分开释放）。如果使用数组，那么只需要一次就可以全部分配出来。

优势： 分配一段连续的内存，减少内存的碎片化。













参考文章：

[1 关于结构体最后的长度为0或1数组的思考](https://blog.51cto.com/u_15352776/3746260)

[2 你必须知道的495个C语言问题  2.7]()



